# Project Architecture & AI Guidelines

This is a Roblox game project, which may be in production or early development (this will be explicitly informed when relevant).

The project follows a scalable, modular, and evolvable architecture, designed for long-term maintenance, team growth, reuse, and exploit resistance.

This document defines the current architectural understanding of the project.
It is not static and is expected to evolve over time based on real development decisions.

Any AI working on this project must fully understand this document BEFORE writing or modifying code.

> **IMPORTANT:** This file contains general architecture rules. For project-specific context (game description, robustness level, current focus), also read `.github/project-context.md`.

---

## Tooling & Project Setup

This project uses:
- **Rojo** for syncing files between VS Code and Roblox Studio
- **Wally** for package management (dependencies are automatically generated in `Packages/` and `ServerPackages/` folders)

Do NOT manually edit files inside `Packages/` or `ServerPackages/` — they are auto-generated by Wally.

### Wally Packages in Use

#### Shared Dependencies (Packages/)

| Package | Purpose | Replaces | When to Use |
|---------|---------|----------|-------------|
| **Signal** | Custom event system | BindableEvents | When you need internal module communication without Roblox instances. Lightweight, typed, and no instance overhead. |
| **Trove** | Cleanup/lifecycle manager | Manual `:Destroy()` calls and `:Disconnect()` | When managing multiple connections, instances, or resources that need cleanup together. Essential for UI, character systems, and anything with a lifecycle. |
| **Observers** | Reactive instance observation | `ChildAdded`, `GetPropertyChangedSignal`, `CollectionService:GetInstanceAddedSignal` | When you need to observe players joining, characters spawning, tags being added, or properties changing. Handles edge cases automatically. |
| **Spring** | Physics-based animation | TweenService (for springy feel) | When you want smooth, natural-feeling animations with overshoot and bounce. Great for UI elements and camera. |
| **Shake** | Screen/camera shake effects | Manual shake implementation | When you need camera shake for impacts, explosions, damage feedback. |
| **TableUtil** | Table manipulation utilities | Manual table operations | When you need deep copy, merge, shuffle, or other common table operations. |

#### Server Dependencies (ServerPackages/)

| Package | Purpose | Replaces | When to Use |
|---------|---------|----------|-------------|
| **ProfileStore** | Player data persistence | DataStoreService directly | When saving/loading player data. Handles session locking, retries, and data corruption prevention automatically. |

---

## Language & Communication Rule (MANDATORY)

All content produced in this project MUST be written in English.

This includes, but is not limited to:
- Code comments
- Variable, function, and module names
- Log messages and prints
- Error messages
- Documentation
- Commit messages (when applicable)
- Any AI-generated explanations inside the codebase

English is required to ensure:
- Consistency across the project
- Easier collaboration with external developers and AIs
- Long-term maintainability and portability of the codebase

No other language should be used inside the project unless explicitly requested by the developer.

---

## 1. Core Architectural Philosophy

- Scalability over shortcuts
- Architecture understandable from multiple angles
- Strict separation of responsibilities
- High modularity and replaceability
- Server-authoritative logic
- Zero cross-responsibility leakage between modules
- Preference for proven, open-source patterns and external libraries when applicable

Each module, service, controller, or manager must do ONE thing and only one thing.

If something feels like it belongs somewhere else, it probably does.

### Coding Style Rules

- **Server scripts do NOT need WaitForChild** - Server scripts run after the game is loaded, so instances are already available. Use direct references.
- **Minimal comments** - Code should be self-explanatory. Only add comments when the logic is complex or non-obvious. Do NOT add obvious comments like "-- Get player" or "-- Teleport to lobby".
- **No header block comments** - Do not add large `--[[ ]]` header blocks describing what the module does. The file name and structure should be self-explanatory.

---

## 2. Execution Flow Overview

### Server
- There is a single server entry script
- This script is responsible ONLY for:
  - Initializing
  - Requiring
  - Starting server-side Services and Managers

### Client
- There is a single client entry script located in `StarterPlayerScripts`
- This script is responsible ONLY for:
  - Initializing
  - Requiring
  - Starting client-side Controllers and Managers
- All client-side modules (Controllers, Managers, Classes, Utils, Data) are located in `ReplicatedStorage/Modules/Client/`
- Only the entry-point script (`Main.client.luau`) lives in `StarterPlayerScripts`

Entry scripts must NOT contain game logic.

---

## 3. Services, Controllers, and Managers

### Services (Server-side)
- Contain server-authoritative game logic
- Orchestrate systems and interactions
- Handle validation, security, and critical systems
- Coordinate Managers
- Never trust the client

Services are the decision-makers of the system.

### Service Dependency Rules (MANDATORY)

Services MUST NOT require other Services directly.

If a Service needs functionality from another Service, one of the following patterns MUST be used:
1. **Extract to Manager**: Move the shared logic to a Manager that both Services can require
2. **Event-based communication via Manager**: Use a shared EventsManager with Signals (see below)
3. **Orchestrate from Main**: If order matters, handle it in the Main script

**Why?**
- Prevents circular dependencies
- Keeps Services focused on orchestration, not implementation
- Makes testing and refactoring easier
- Maintains clear responsibility boundaries

**Allowed requires in Services:**
- Managers (Server, Shared, or Client if on client)
- Data modules
- Utils
- Packages

**NOT allowed requires in Services:**
- Other Services

### Service Communication via EventsManager (MANDATORY)

When Services need to react to events from other Services, use a shared **EventsManager**:

```lua
-- EventsManager.luau (Shared Manager)
local Signal = require(Packages.Signal)

local EventsManager = {}

-- Define game-wide events here
EventsManager.PlayerCashChanged = Signal.new()
EventsManager.PlayerRebirthed = Signal.new()
EventsManager.ItemPlaced = Signal.new()

return EventsManager
```

```lua
-- EconomyService.luau (fires the event)
local EventsManager = require(path.to.EventsManager)

function EconomyService.AddCash(player, amount)
    -- ... logic ...
    EventsManager.PlayerCashChanged:Fire(player, newCash)
end
```

```lua
-- AchievementService.luau (listens to the event)
local EventsManager = require(path.to.EventsManager)

function AchievementService.Start()
    EventsManager.PlayerCashChanged:Connect(function(player, cash)
        -- React to cash changes
    end)
end
```

**This pattern ensures:**
- Services don't require each other
- Communication is explicit and traceable
- The Manager owns the event definitions

---

### Controllers (Client-side)
- Handle input, UI logic, and visual feedback
- React to replicated state
- Never contain critical logic
- Never decide game state

Controllers are reactive, not authoritative.

---

### Managers (Data Ownership & Mutation)

Managers are responsible for:
- Storing information
- Reading information
- Mutating information in a controlled way

They may exist as:
- Server-only
- Client-only
- Shared (when safe)

Examples:
- PlayerDataManager
- InventoryManager
- MatchStateManager
- RemotesManager

### Manager Rules (MANDATORY)

- Managers DO NOT orchestrate systems
- Managers DO NOT listen to or react to other Managers
- Managers DO NOT alter their own state autonomously

Managers expose functions.
Who decides WHEN and WHY those functions are called is always a Service or a higher-level system (or explicit object logic).

---

### Initialization Pattern (MANDATORY)

All Services and Controllers MUST follow a **two-phase initialization** pattern.
Managers MAY implement `Init()` and/or `Start()` only when they need setup logic (e.g., RemotesManager creating remotes). Simple Managers that only read/write values do not need these methods.

**IMPORTANT:** If a module has `Init()`, it MUST also have `Start()` (even if empty), and vice-versa. Both methods must be called in the Main script.

#### Phase 1: `Init()`
- Called first on ALL modules before any `Start()` is called
- Used for:
  - Setting up internal state
  - Creating instances (e.g., remotes, folders)
  - Preparing data structures
  - Requiring dependencies
- Must NOT assume other modules have started
- Must NOT call methods on other modules that depend on their `Start()` having run

#### Phase 2: `Start()`
- Called AFTER all modules have completed `Init()`
- Used for:
  - Connecting to events
  - Starting listeners
  - Beginning runtime behavior
  - Interacting with other modules safely
- At this point, all modules are guaranteed to be initialized

#### Execution Order in Main Scripts

```lua
-- 1. Require all modules
local ServiceA = require(...)
local ManagerB = require(...)

-- 2. Init phase (order may matter for dependencies)
ManagerB.Init()
ServiceA.Init()

-- 3. Start phase (all modules are now initialized)
ManagerB.Start()
ServiceA.Start()
```

This pattern ensures that:
- RemotesManager can create remotes in `Init()` before any Service tries to use them in `Start()`
- Dependencies are always available when needed
- No race conditions between module initialization

If a module needs to manipulate data, it MUST go through the appropriate manager.
It must NEVER manipulate data directly.

---

## 4. Data vs Logic Separation

### Data Modules
These modules ONLY store structured data:
- Game settings
- Item definitions
- Balance values
- Static configurations
- Communication schemas (e.g. remotes definitions)

They must NOT:
- Run logic
- Modify runtime state
- Modify player data
- Communicate with services directly

### Settings Module (MANDATORY)

Every project MUST have a `Settings.luau` module located at:
`ReplicatedStorage/Modules/Shared/Data/Settings.luau`

This module acts as the **game constraints/configuration**, similar to a `CONSTRAINTS` table in other game architectures.

It should contain values like:
- Max players per match
- Match timeout duration
- Lobby wait time
- Respawn delay
- Round duration
- Any other game-wide configuration values

Example structure:
```lua
local Settings = {
    Match = {
        MaxPlayers = 8,
        MinPlayersToStart = 2,
        LobbyTimeout = 30,
        RoundDuration = 180,
    },
    Player = {
        RespawnDelay = 5,
        MaxLives = 3,
    },
}

return Settings
```

All Services and systems that need these values MUST read from this module.
Hardcoded magic numbers are NOT allowed.

---

### Logic Modules
- Operate on data
- Use managers to read/write state
- Are orchestrated by Services or Controllers
- Never embed static configuration values directly

---

## 5. Replication, Security & Communication

### Replication Rules
- Anything non-critical and required for rendering (e.g. item name, icon, price display) may be stored in ReplicatedStorage
- Anything critical (logic, validation, calculations, authority) MUST stay server-side

Example:
- Item price (display): replicated
- Item purchase validation & effects: server-only

### Studio vs Production Data (MANDATORY)

When working with **any persistent data** (DataStoreService, ProfileStore, OrderedDataStore, etc.), the code MUST use a separate key/store for Studio testing.

Use `RunService:IsStudio()` to append a suffix to store names:

```lua
local RunService = game:GetService("RunService")

local storeName = "PlayerData" .. (RunService:IsStudio() and "_Studio" or "")
local playerDataStore = ProfileStore.New(storeName, PlayerDataTemplate)
```

This ensures:
- Production data is never corrupted during development
- Studio testing uses isolated data
- No accidental data leaks between environments

This rule applies to ALL data persistence systems, not just player data.

---

### Server ↔ Client Communication (Remotes)

Communication between Server and Client is extremely important and strictly organized.

- Remotes are created at runtime
- The RemotesManager is a **Shared Manager** located at `ReplicatedStorage/Modules/Shared/Managers/RemotesManager.luau`
- On the Server: RemotesManager creates remotes during its Init() phase
- On the Client: RemotesManager catalogs existing remotes for access
- Remote definitions are stored in:

ReplicatedStorage/Modules/Shared/Data/RemotesData

RemotesData:
- Describes which remotes exist
- Their type (Event or Function)
- Their intended purpose

No system should create remotes ad-hoc.
No hardcoded remote creation outside RemotesManager.

---

## 6. UI Guidelines (MANDATORY)

### No Dynamic GUI Creation

This project does NOT use reactive UI frameworks like:
- Roact
- Fusion
- Vide

All UI is handled through **references and cloning**:
- UI elements are pre-built in Roblox Studio
- Templates are cloned when needed
- References point to existing GUI elements

### Reference Pattern

All UI references MUST be declared at the TOP of the module:

```lua
-- UI References (MUST be at the top)
local Players = game:GetService("Players")
local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

local mainMenu = playerGui:WaitForChild("MainMenu")
local playButton = mainMenu:WaitForChild("PlayButton")
local settingsFrame = mainMenu:WaitForChild("SettingsFrame")

-- Templates
local templates = playerGui:WaitForChild("Templates")
local itemTemplate = templates:WaitForChild("ItemTemplate")
```

### Reusable UI Animations

UI animations MUST NOT be rewritten for every button, frame, or element.

Create a utility module at `ReplicatedStorage/Modules/Client/Utils/UIAnimations.luau` (or similar) that provides:
- Button hover/press animations
- Frame show/hide transitions
- Fade in/out effects
- Scale animations
- Any other common UI animations

Example usage:
```lua
local UIAnimations = require(path.to.UIAnimations)

UIAnimations.fadeIn(frame, 0.3)
UIAnimations.buttonPress(button)
UIAnimations.slideIn(panel, "left", 0.5)
```

This ensures consistency and reduces code duplication.

---

## 7. Open-Source & External Code Usage

This architecture is designed to be:
- Understood from multiple perspectives
- Easy to onboard new developers or AIs
- Compatible with proven patterns

Therefore:
- Prefer open-source, battle-tested external modules when applicable
- Avoid reinventing solved problems
- External code must:
  - Respect this architecture
  - Be adapted if necessary
  - Never violate responsibility boundaries

Reusability and clarity are preferred over cleverness.

---

## 8. Single Responsibility Rule (Mandatory)

A function or module must ONLY do what its name and purpose imply.

Examples:
- An Item module MUST NOT save player data
- A Data module MUST NOT run logic
- A Controller MUST NOT validate game rules
- A Manager MUST NOT orchestrate systems

If a needed manager or abstraction does not exist, create one following the same architectural principles.

---

## 9. Naming Conventions (MANDATORY)

All module files MUST use a suffix that indicates their role:

- **Services**: `CombatService.luau`, `MatchmakingService.luau`
- **Controllers**: `InputController.luau`, `UIController.luau`
- **Managers**: `PlayerDataManager.luau`, `InventoryManager.luau`
- **Data Modules**: `ItemsData.luau`, `RemotesData.luau`
- **Classes**: `Weapon.luau`, `Character.luau` (no suffix, PascalCase)
- **Utils**: `MathUtils.luau`, `StringUtils.luau`

This naming convention ensures clarity and quick identification of module responsibilities.

---

## 10. Classes, Utils, and Types

### Classes

Classes are used to create objects with state and behavior.

They MUST be placed according to where they will be used:
- `ReplicatedStorage/Modules/Shared/Classes/` — Used by both Server and Client
- `ReplicatedStorage/Modules/Client/Classes/` — Client-only classes
- `ServerScriptService/Scripts/Modules/Classes/` — Server-only classes

#### Composition Over Inheritance (When Using OOP)

When creating Classes that need multiple behaviors, use **Sub-Object Composition** instead of **Multiple Inheritance**.

**Why:**
- Multiple inheritance creates ambiguity (Diamond Problem)
- Deep metatable chains hurt performance and debugging
- Lua does not natively support multiple inheritance

**Pattern: Sub-Object Composition**

Each behavior system is a complete class with its own data and methods. The parent class contains instances of these sub-classes:
- Each sub-object has its own metatable (methods don't duplicate per instance)
- Data is encapsulated within each sub-object
- No need to manually declare each property in the parent class

```lua
-- Shared/Classes/HealthClass.luau
local Signal = require(path.to.Signal)

local HealthClass = {}
HealthClass.__index = HealthClass

function HealthClass.new(maxHealth)
    local self = setmetatable({}, HealthClass)
    
    self.Current = maxHealth or 100
    self.Max = maxHealth or 100
    
    self.Changed = Signal.new()
    self.Died = Signal.new()
    
    return self
end

function HealthClass:TakeDamage(amount)
    local old = self.Current
    self.Current = math.max(0, self.Current - amount)
    self.Changed:Fire(old, self.Current)
    
    if self.Current <= 0 then
        self.Died:Fire()
    end
end

function HealthClass:Heal(amount)
    local old = self.Current
    self.Current = math.min(self.Max, self.Current + amount)
    self.Changed:Fire(old, self.Current)
end

function HealthClass:IsDead()
    return self.Current <= 0
end

function HealthClass:GetPercent()
    return self.Current / self.Max
end

function HealthClass:Destroy()
    self.Changed:Destroy()
    self.Died:Destroy()
end

return HealthClass
```

```lua
-- Shared/Classes/InventoryClass.luau
local Signal = require(path.to.Signal)

local InventoryClass = {}
InventoryClass.__index = InventoryClass

function InventoryClass.new(maxSlots)
    local self = setmetatable({}, InventoryClass)
    
    self.Items = {}
    self.MaxSlots = maxSlots or 10
    
    self.ItemAdded = Signal.new()
    self.ItemRemoved = Signal.new()
    
    return self
end

function InventoryClass:Add(item)
    if #self.Items >= self.MaxSlots then
        return false, "Full"
    end
    table.insert(self.Items, item)
    self.ItemAdded:Fire(item)
    return true
end

function InventoryClass:Remove(item)
    local index = table.find(self.Items, item)
    if not index then return false end
    table.remove(self.Items, index)
    self.ItemRemoved:Fire(item)
    return true
end

function InventoryClass:Has(item)
    return table.find(self.Items, item) ~= nil
end

function InventoryClass:Destroy()
    self.ItemAdded:Destroy()
    self.ItemRemoved:Destroy()
end

return InventoryClass
```

```lua
-- Classes/Prisoner.luau
local HealthClass = require(path.to.HealthClass)
local InventoryClass = require(path.to.InventoryClass)
local Trove = require(path.to.Trove)

local Prisoner = {}
Prisoner.__index = Prisoner

function Prisoner.new(id, data)
    local self = setmetatable({}, Prisoner)
    
    -- Identity
    self.Id = id
    self.Name = data.Name
    
    -- Sub-systems (composition) - each is a complete object!
    self.Health = HealthClass.new(data.MaxHealth or 100)
    self.Inventory = InventoryClass.new(data.InventorySize or 10)
    
    -- Prisoner-specific data
    self.Heat = 0
    self.Money = data.StartMoney or 0
    
    -- Lifecycle
    self.Trove = Trove.new()
    
    -- Connect sub-system events
    self.Trove:Add(self.Health.Died:Connect(function()
        self:OnDeath()
    end))
    
    return self
end

-- Prisoner-specific methods
function Prisoner:OnDeath()
    self.Heat = 0
    -- Death logic...
end

function Prisoner:AddHeat(amount)
    self.Heat = math.min(100, self.Heat + amount)
end

function Prisoner:Destroy()
    self.Health:Destroy()
    self.Inventory:Destroy()
    self.Trove:Clean()
end

return Prisoner
```

**Usage:**
```lua
local prisoner = Prisoner.new("p1", {
    Name = "João",
    MaxHealth = 100,
    InventorySize = 10,
})

-- Access through sub-objects
prisoner.Health:TakeDamage(20)
prisoner.Health:Heal(10)
print(prisoner.Health:IsDead())     -- false
print(prisoner.Health.Current)      -- 90

prisoner.Inventory:Add("key")
print(prisoner.Inventory:Has("key")) -- true

-- Events
prisoner.Health.Died:Connect(function()
    print(prisoner.Name .. " died!")
end)

-- Cleanup
prisoner:Destroy()
```

**When single inheritance is acceptable:**
- Simple parent-child relationship (e.g., `Weapon` → `Sword`)
- No more than 2 levels deep
- No shared ancestors between siblings

**This pattern is NOT mandatory** — only use it when your Class needs multiple distinct behaviors. Simple Classes can use basic metatables.

### Utils / Helpers

Utility modules contain generic, reusable helper functions (math, string manipulation, etc.).

They MUST be placed according to where they will be used:
- `ReplicatedStorage/Modules/Shared/Utils/` — Used by both Server and Client
- `ReplicatedStorage/Modules/Client/Utils/` — Client-only utilities
- `ServerScriptService/Scripts/Modules/Utils/` — Server-only utilities

### Types (Optional)

When a project requires shared type definitions (Luau types), they may be placed in:
- `ReplicatedStorage/Modules/Shared/Types/`

Types are optional and should be used when they improve code clarity and maintainability.

---

## 11. AI Behavior Expectations & Architectural Learning

The AI is NOT expected to only execute tasks.

The AI is expected to:
- Think architecturally
- Suggest improvements
- Detect responsibility leaks
- Question bad patterns (even if they work)
- Prefer reuse over creation when possible

### Self-Correction & Rule Evolution

If the developer modifies or corrects something you implemented:
- You MUST infer why the change was made
- You MUST adapt your future behavior to avoid repeating the same mistake

Additionally, you MUST consider that the original understanding, rule, or instruction may have been incomplete, unclear, or incorrect.

If you detect that:
- You followed an existing rule or guideline (X)
- But the developer adjusted the result to a different approach (Y)

Then you MUST assume one of the following:
- The rule was ambiguous
- The rule was outdated
- The rule does not fully represent the intended architecture

In this case, you MUST:
- Update your internal understanding so that future implementations follow Y instead of X
- Treat Y as the new preferred pattern unless explicitly reverted
- Reflect this change as an evolution of the architecture, not an exception

If the correction represents a broader architectural shift:
- You SHOULD suggest updating this document
- You SHOULD be able to summarize this learned adjustment when asked, so it can be exported externally

When in doubt between a written rule and a developer correction, the developer correction always takes precedence.

### Document Evolution Rule (MANDATORY)

Whenever the AI learns something NEW about the project architecture that is NOT documented in this file:
- The AI MUST **immediately update this document** with the new rule or clarification
- The AI MUST NOT assume the new rule is an exception
- The AI MUST treat undocumented patterns as potential additions to the architecture
- The AI MUST NOT wait for permission to update - if a correction was made, the document should reflect it

**When to update this document:**
- When the developer corrects an implementation approach
- When a new pattern emerges from development decisions
- When an existing rule is clarified or made more strict
- When a new constraint is discovered through errors or feedback

**How to update:**
- Add the rule in the appropriate section
- Use clear, unambiguous language
- Include examples if the rule is complex
- Mark new rules as (MANDATORY) if they are strict requirements

### Linter Behavior (MANDATORY)

The AI acts as a **code linter** for architectural rules:
- If the AI detects code or structure that violates the rules in this document, it MUST:
  1. Correct the violation
  2. Inform the developer what was corrected and why
- This applies even when the developer writes quick/informal code
- The AI ensures consistency is maintained at all times

### Knowledge Persistence (MANDATORY)

When the developer answers questions or clarifies something about the project:
- The AI MUST add the new information to `.github/project-context.md`
- Information should be organized in the appropriate section
- This ensures knowledge persists across sessions and AI instances

### Task Feedback (MANDATORY)

When the AI has questions about a task and the developer answers them:
- The AI MUST write a brief summary below the task checkbox explaining what was missing from the original prompt
- This helps the developer improve future task descriptions
- Format: `> **Clarifications needed:** [brief list of what was unclear]`

This ensures the document remains the single source of truth and evolves alongside the project.

---

## 12. First-Time Project Analysis (MANDATORY)

Before working on this project for the first time, you MUST:

1. Explore the full project structure
2. Read Main scripts (server and client)
3. Inspect Services, Controllers, and Managers
4. Understand dependencies between modules
5. Identify:
   - What each module affects
   - Who owns data
   - Who orchestrates behavior

Do NOT start coding before this analysis is complete.

---

## 13. Questions & Uncertainty Handling

If at any point you are:
- Unsure about where something belongs
- Unsure which layer should own logic
- Unsure how this architecture intends something to work
- Unsure whether a pattern violates scalability

You MUST ask the developer BEFORE proceeding.

Assumptions without confirmation are discouraged.

---

## 14. Explorer Structure (High-Level)

ServerScriptService
- Scripts/
  - Main.server.luau
  - Modules/
    - Packages/ (Automatically Generated by Wally)
    - Services/
    - Managers/
    - Classes/
    - Utils/
    - Data/

StarterPlayer
- StarterPlayerScripts
  - Scripts/
    - Main.client.luau

ReplicatedStorage
- Assets/ (Roblox Studio Only)
- Remotes/ (Created at Runtime by RemotesManager)
- Modules/
  - Packages/ (Automatically Generated by Wally)
  - Shared/
    - Managers/
      - RemotesManager.luau
    - Classes/
    - Utils/
    - Types/ (Optional)
    - Data/
      - RemotesData.luau
  - Client/
    - Managers/
    - Controllers/
    - Classes/
    - Utils/
    - Data/

ServerStorage (Roblox Studio Only)
- Assets/

This structure exists to enforce boundaries, not convenience.

---

## 15. Robustness Levels (Project Performance Tiers)

Projects may have different performance and optimization requirements. The current project's robustness level will be declared at the top of this document when relevant.

### Level 1: Basic (Default)
**Use when:** Early development, prototyping, or simple games with minimal performance concerns.

- Standard code practices
- Basic cleanup when obvious (e.g., disconnecting events when UI closes)
- No mandatory Trove usage
- Focus on functionality over optimization

### Level 2: Standard
**Use when:** Production games with moderate complexity.

- Trove usage recommended for UI Controllers and character-related systems
- Connections should be properly managed
- Templates should be cleaned up when no longer needed
- Basic memory awareness

### Level 3: Optimized (Performance-Critical)
**Use when:** High-performance games, games with many players, or complex systems.

- **Trove is MANDATORY** for:
  - All UI animations and connections
  - Character systems
  - Any system with a lifecycle
- All animation/utility functions MUST return cleanup handles:
  ```lua
  -- UIAnimations MUST return Trove or cleanup function
  local cleanup = UIAnimations.fadeIn(frame, 0.3)
  -- Later, when GUI closes:
  cleanup() -- or trove:Clean()
  ```
- Connections (like `Activated`, `MouseEnter`) MUST be tracked and cleaned
- Object pooling should be considered for frequently created/destroyed instances
- Minimize instance creation at runtime

### Example: UI with Robustness Level 3

```lua
local Trove = require(path.to.Trove)
local UIAnimations = require(path.to.UIAnimations)

local MenuController = {}
local trove = Trove.new()

function MenuController.Open()
    local frame = menuFrame
    frame.Visible = true
    
    -- Animation returns cleanup, added to trove
    trove:Add(UIAnimations.fadeIn(frame, 0.3))
    
    -- Button connections tracked by trove
    trove:Connect(playButton.Activated, function()
        -- handle play
    end)
end

function MenuController.Close()
    -- Clean ALL connections and animations at once
    trove:Clean()
    menuFrame.Visible = false
end
```

---

Failure to respect this document results in invalid implementations.
